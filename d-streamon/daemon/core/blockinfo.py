from block import BlockInfo, GateInfo, VariableInfo, IntegerRange

block_infos = {"L4Demux": BlockInfo("L4Demux", "False", [GateInfo("output", "out_tcp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_udp", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_unknown", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "This blocks simply takes Packet messages into account and demultiplexes them across three possible output    gates depending on their transport protocol.    In particular, a TCP packets in forwarded through the out_tcp gate, a UDP through out_udp and any other packet    through out_unknown.", "Demultiplexes packets based on their transport protocol", False), "PcapSource": BlockInfo("PcapSource", "True", [GateInfo("output", "sniffer_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element source {\n         attribute type {'live' | 'trace'}\n         attribute name {text}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <source type='live' name='eth0'>\n         or\n         <source type='trace' name='trace.pcap'>\n \n       <bpf_filter expression=' '>\n      </params>\n    </paramsexample>\n", [], "Captures traffic from a local interface or pcap trace file and outputs      packets using a Packet message. If the source parameter is set to live,      the name parameter should be an interface's name (e.g., eth0). If the      source type is set to trace, then the name should be the full path to a      pcap trace file (e.g., /tmp/mytrace.pcap). Use the bfp paramter to filter      traffic using BFP syntax.", "Captures traffic from a local interface or pcap trace file", True), "RRDemux": BlockInfo("RRDemux", "False", [GateInfo("input", "input", "Any", IntegerRange(0, 0)), GateInfo("output", "output1", "Any", IntegerRange(0, 0)), GateInfo("output", "output2", "Any", IntegerRange(0, 0)), GateInfo("output", "outputN", "Any", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element gates {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <gates number='5' />\n      </params>\n    </paramsexample>\n", [], "Receives messages and sends them alternatively through a configured number      of output gates.  	   It uses the Round Robin algorithm to select the next gate.  	   There can be any number of output gates named outputX, with X from 1 to 	   the configured number of gates.", "Sends received messages through N gates alternatively", False), "FlowPrinter": BlockInfo("FlowPrinter", "False", [GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Flow message and prints its associated information (as returned by the methods in the Flow class)", "Prints meta-information regarding a flow", False), "PerFlowStats": BlockInfo("PerFlowStats", "True", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element export_only_expired {''}?\n       element timeout{\n            attribute ms {xsd:integer}\n            }?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n           <export_only_expired/>\n           <timeout ms='500'/>\n      </params>\n    </paramsexample>\n", [], "", "Captures traffic from a local interface or pcap trace file", False), "SynFloodDetector": BlockInfo("SynFloodDetector", "False", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_alert", "PairMsg(int, std::vector(unsigned int))", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cusum {\n         attribute threshold {integer}\n         attribute offset {integer}\n         attribute mean_window {integer}\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <cusum threshold='50' offset='10' mean_window='20' />\n      </params>\n    </paramsexample>\n", [], "Detects TCP SYN Flooding from counters in sketches.  	   Sketches are received regularly with the number of TCP SYN packets  	   seen by destination IP since the last sketch was sent.      The CUSUM algorithm is used to detect abrupt changes in the numbers of      the sketch. Its parameters can be configured:  	    threshold is the indicator value over which an alarm will be raised       offset is the variation in counts considered normal       mean_window is the number of sketches on which the mean is computed      When a SYN flooding is detected, it is logged and a message is sent      through out_alert with the indexes of the cells in alarm. 	   This message may be used to identify the target of the attack.", "Detects TCP SYN Flooding from counters in sketches", False), "Null": BlockInfo("Null", "False", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Debug blocks which discards every message it receives.    It takes no configuration parameters.", "Debug block discarding messages", False), "SynthSource": BlockInfo("SynthSource", "True", [GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element rate {\n         attribute pps {xsd:integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <rate pps='10000'/>\n      </params>\n    </paramsexample>\n", [], "Generates TCP/IP packets with random IP addresses and ports.    The number of packets per second can be tuned as a configuration parameter.", "Generates synthetic traffic with random addresses and ports", True), "TCPFlagCounter": BlockInfo("TCPFlagCounter", "False", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("input", "in_alarm", "PairMsg(int, std::vector(unsigned int))", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element export {\n         attribute period {integer}\n       }\n       element sketch {\n         attribute width {integer}\n         attribute depth {integer}\n         element hash {\n           attribute a {integer}\n           attribute b {integer}\n         }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n       <params>\n       <export period='500000' />\n       <sketch width='1024' depth='2'>\n         <hash a='12' b='4587' />\n         <hash a='458' b='56332' />\n       </sketch>\n      </params>\n    </paramsexample>\n", [], "Counts the TCP SYN packets sent to each IP. Stores the counts  	   in a CMS sketch and sends the sketch regularly.  	   In a future version, the TCP flags counted will be configureable.   	   Packets are received through the gate in_pkt.  	   The CMS sketch can be configured:  	    width is the number of values each hash function can take  	    depth is the number of hash functions       hash functions may be defined by their parameters a and b. If there        are not at least 'depth' functions defined, they will be chosen 		 randomly.  	   The export rate can be configured:  	    period is the number of microseconds between each sketch is sent.  	   Alerts can also be received through gate in_alert. These      alerts contain the indexes of counts in alarm. This blocks associates      them with a destination IP that it logs when an alert is received.      The destination IP is determined using a list of recently-seen IPs.", "Counts TCP SYN packets by target IP in sketches", False), "CDFGenerator": BlockInfo("CDFGenerator", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element cdf_build {\n                attribute interval {xsd:integer}\n            }\n       element cdf_param{\n            attribute min {xsd:integer}\n            attribute max {xsd:integer}\n            attribute bin {xsd:integer}\n            }\n       element diff_priv{\n            attribute epsilon {xsd:float}\n            }\n        }\n     }\n    </paramsschema>\n", "    <paramsexample>\n        <params>\n             <build_cdf interval='2000'/> #millisecond\n             <cdf_param min='0' max='1500' bin='150'/>\n             <diff_priv epsilon='0.8'/> #if -1 do not add noise\n        </params>\n    </paramsexample>\n", [], "Implements a block that print the Cumulative Distribution Function (CDF) of the packet size every interval,        adding a noise depending on the epsilon value.        Configuration parameters allow to tune the endpoints of the CDF, the bin width and to add noise", "Captures traffic from a local interface or pcap trace file", False), "PacketCounter": BlockInfo("PacketCounter", "False", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element notimer {text}?\n       }\n \n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [VariableInfo("PacketCounter", "pktcount", "integer", "read"), VariableInfo("PacketCounter", "bytecount", "integer", "read")], "Keeps packet and byte counts of traffic going through it and logs,      every 0.5 seconds, the packet rate.      An xml parameter can be used in order to disable the timer mechanism.", "Keeps packet and byte counts of traffic going through it.", False), "PacketPrinter": BlockInfo("PacketPrinter", "False", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n      </params>\n    </paramsexample>\n", [], "Receives a Packet message and prints its associated information (as returned by the methods in the Packet class)", "Prints meta-information regarding a packet", False), "IPFIXExporter": BlockInfo("IPFIXExporter", "False", [GateInfo("input", "in_msg", "Msg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element domain {xsd:integer},\n        element export {\n            attribute transport {'udp'|'tcp'|'sctp'},\n            attribute host  {text},\n            attribute port {xsd:integer}?\n            } |\n        element file {\n            attribute name {text}\n        }\n       }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n        <domain id='31'/>\n        <export host='131.114.54.11' port='113' transport='udp'/>\n        or\n        <file name='dump'/>\n      </params>\n    </paramsexample>\n", [], "This blocks received a message and exports through an IPFIX channel.   This may be a TCP connection, a UDP message, or a file   The details of the IPFIX templates associated to an internal blockmon message are retrieved from the   factory in MsgRegistry and kept in a local cache.   Notice that this block can handled whatever message class includes a registration to the message registry.   If the registry entry for the message type is not found, an exception is thrown.", "Exports BlockMon internal messages by using IPFIX", True), "TopNFlowSelector": BlockInfo("TopNFlowSelector", "both", [GateInfo("output", "out_flow", "Flow", IntegerRange(0, 0)), GateInfo("input", "in_flow", "Flow", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n        element top_flows{\n        attribute number {xsd:integer}\n        }?\n        element period{\n        attribute msecs {xsd:integer}\n        }?\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n             <top_flows number='10'/>\n             <period msecs='4000'/>\n      </params>\n    </paramsexample>\n", [], "Receives Flow messages and keeps a list of the N messages with the highest number of packets         Upon expiration of a timer, it sends all of them out of its out gate.         The number N of messages to be selected, along with the flush period, are optional configuration parameters.         Default values are 10 messages and 100ms respectively", "Selects the flows with the highest number of packets", False), "PFQSource": BlockInfo("PFQSource", "True", [GateInfo("output", "source_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element queues {\n           attribute device {text}\n           element queue {\n                attribute number {xsd:integer}\n                }\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n   <params>                                                                                                                                 \n       <queues device='eth3'>\n           <queue number='0'/>\n       </queues> \n   </params>\n    </paramsexample>\n", [], "This block is a wrapper to the PFQ capturing engine (http://netgroup.iet.unipi.it/software/pfq/)    A block of this kind can be associated to a network interface or to a subset of its associated hardware queues.    This is specified as a configuration parameter: a set of queues for the interface can be specified, if this is empty the    block captures all of to the packets on the interface.    This block supports batch message allocation in order to optimize performance", "Captures traffic from a local interface by means of the PFQ capturing engine", True), "SketchMerger": BlockInfo("SketchMerger", "False", [GateInfo("input", "in_sketch", "SketchMsg", IntegerRange(0, 0)), GateInfo("output", "out_sketch", "SketchMsg", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element merge {\n         attribute number {integer}\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <merge number='3' />\n      </params>\n    </paramsexample>\n", [], "Receive CMS sketches and merges them to send only one.  	   All sketches received should have the same width and depth, and use the      same hash functions.  	   When the configured number of sketches have been received,  	   they are merged together and sent, and the cycle restarts.", "Receives CMS sketches and merges them.", False), "SketchFlowCounter": BlockInfo("SketchFlowCounter", "False", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n     }\n    </paramsschema>\n", "    <paramsexample>\n    </paramsexample>\n", [], "Counts the number of packets per flow in all traffic. 	   A flow is identified by its source IP / dest. IP / source port / dest. port / protocol.      Only TCP and UDP packets are considered.  	   Each time a packet is received, the number of packets of its flow is logged.", "Counts the number of packets per flow in all traffic", False), "IpDumpAnonymizer": BlockInfo("IpDumpAnonymizer", "both", [GateInfo("input", "in_pkt", "Packet", IntegerRange(0, 0)), GateInfo("output", "out_pkt", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element anon {\n         attribute src {'True' | 'False'}?\n         attribute dst {'True' | 'False'}?\n       }\n     }\n    </paramsschema>\n", "    <paramsexample>\n      <params>\n         <anon src='True'/>\n      </params>\n    </paramsexample>\n", [], "", "Anonymizes ip addresses in a Packet message", False), "PFRingSource": BlockInfo("PFRingSource", "True", [GateInfo("output", "src_out", "Packet", IntegerRange(0, 0))], "    <paramsschema>\n     element params {\n       element queues {\n         attribute device {text}\n         element queue \n         {\n              attribute number {xsd:integer}  \n         }\n       }\n       element bpf_filter {text}?\n     }\n    </paramsschema>\n", "    <paramsexample>\n       <params>\n            <queues device='eth0' >\n            	<queue number='1'/>\n            	<queue number='2'/>\n            </queues>\n       </params>\n \n    </paramsexample>\n", [], "Wrapper to the PFRing capturing engine (https://svn.ntop.org/svn/ntop/trunk/PF_RING/).      This block can capture the traffic coming from a network interface or just of a hardware queue thereof.      If no specific queues are specified in the configuration, the whole interface is monitored.      In order for this block to compile, the PF_RING user space library needs to be installed (make install can do it).      In order for this blocks to work, the PF_RING module has to be loaded beforehand.", "Wrapper to the PF_RING capturing engine", True)}

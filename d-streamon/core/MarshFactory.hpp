#ifndef __MARSH_FACTORY
#define __MARSH_FACTORY

#include <map>
#include <memory>
#include <netinet/in.h>
#include <Msg.hpp>
#include <Buffer.hpp>
#include <ClassId.hpp>

namespace bm
{

    class BaseMarshall
    {
    public:
        BaseMarshall()
        {}

        virtual ~BaseMarshall()
        {}

        virtual int marshall(const Msg&, mutable_buffer<char>) const = 0;
        virtual std::shared_ptr<const Msg> unmarshall(const_buffer<char>) const =0;
    };

    /*
     * small header for marshalling:(precedes the actual buffer)
     *8 bytes:
     *int code 
     *unsigned int length
     * */

    class MarshallFactory
    {
        std::map<int, std::shared_ptr<BaseMarshall>> m_map;

        MarshallFactory(): m_map()
        {}

        MarshallFactory(const MarshallFactory&) = delete;
        MarshallFactory& operator=(const MarshallFactory&) = delete;

    public:
        static const int HEAD_SIZE = 2*sizeof(unsigned int);

        static MarshallFactory& 
        instance()
        {
            static MarshallFactory the_factory;
            return the_factory;
        }

        int 
        marshall(const Msg& inm, mutable_buffer<char> inb)
        {
            int newlen=inb.len()-HEAD_SIZE;
            if(newlen<=0)
                throw std::runtime_error("marshalling:: provided buffer is too small");

            auto it = m_map.find(inm.type());
            if(it==m_map.end())
                throw std::runtime_error("marshalling:: message type not supported");

            *(reinterpret_cast<int*>(inb.addr())) = htonl(inm.type());

            int m_len = it->second->marshall(inm,mutable_buffer<char>(inb.addr()+HEAD_SIZE,newlen));

            *(reinterpret_cast<unsigned int*>(inb.addr()+sizeof(int))) = htonl(m_len);
            return m_len+HEAD_SIZE;
        }

        std::shared_ptr<const Msg> 
        unmarshall(const_buffer<char> inb)
        {
            std::map<int, std::shared_ptr<BaseMarshall> >::iterator it;
            int type=ntohl(*reinterpret_cast<const int*> (inb.addr()));	
            unsigned int len=ntohl(*reinterpret_cast<const unsigned int*> (inb.addr()+sizeof(int)));

            it=m_map.find(type);
            if(it==m_map.end())
                throw std::runtime_error("marshalling:: message type not supported");
            return it->second->unmarshall(const_buffer<char>(inb.addr()+HEAD_SIZE,len));
        }

        void f_register(int msg_code, std::shared_ptr<BaseMarshall>&& inb)
        {
            if(m_map.find(msg_code)!=m_map.end())
                return;
            m_map[msg_code]=std::move(inb);
        }
    };

    //TODO:: message with hard-coded message code (not generated by type_to_id) are not yet compatible with this factory: a type-traits mechanism is needed

    template <typename M, typename T>
    class marshall_factory_register
    {
    public:
        marshall_factory_register()
        {
            MarshallFactory::instance().f_register(type_to_id<T>::id(), typename std::shared_ptr<BaseMarshall>(static_cast<BaseMarshall*>(new M)));
        }	
    };


#define REGISTER_MARSHALLING_MODULE(module,type)\
    namespace\
    {\
        marshall_factory_register<module,type> the_local_factory_register; \
    } 
}		



#endif
